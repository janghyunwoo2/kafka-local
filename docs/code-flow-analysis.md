# 🔄 파일들의 흐름 설명

## 🎯 전체 파이프라인 구조
**[bakery-producer.py]** → **[Kafka Topic: 'bk-orders']** → **[bakery-consumer.py]**

---

## 📦 1. bakery-producer.py - 고객 주문 생성 및 카프카 전송

### 목적
스마트폰 앱에서 발생하는 고객 주문 데이터를 생성하여 카프카로 전송

### 흐름
1. **카프카 Producer 초기화**
   - 로컬 카프카 서버(`127.0.0.1:9092`)에 연결
   - JSON 직렬화 설정
   ↓
2. **주문 데이터 생성 (무한 루프)**
   - 랜덤 메뉴 선택 (빅맥세트, 김밥세트, 돈까스세트, 식빵, 케이크)
   - 랜덤 수량 생성 (1~5개)
   - 주문 시간 및 매장 코드 포함
   ↓
3. **카프카 토픽으로 전송**
   - `bk-orders` 토픽에 메시지 발행
   - 버퍼 강제 플러시
   - 약 1초 간격으로 반복

**스케줄**: 프로그램 실행 시 무한 루프로 계속 주문 생성

---

## 📦 2. bakery-consumer.py - 주문 수신 및 처리

### 목적
매장 단말기 역할로, 카프카에 저장된 주문 메시지를 실시간 수신하여 주문 접수 처리

### 흐름
1. **카프카 Consumer 초기화**
   - `bk-orders` 토픽 구독
   - 최신 메시지부터 읽기 설정 (`auto_offset_reset='latest'`)
   - 컨슈머 그룹 ID: `factory_group`
   ↓
2. **주문 대기 상태 진입**
   - 메시지 수신 대기 (무한 루프)
   - "매장 주문 모니터 가동 → 주문 대기중" 출력
   ↓
3. **메시지 수신 및 처리**
   - 카프카에서 메시지 수신 시 즉시 처리
   - 주문 번호 자동 증가 부여
   - 주문 접수 메시지 출력
   - 3초마다 대기 상태 확인

**스케줄**: 프로그램 실행 시 무한 루프로 메시지 대기 및 수신

---

## 🎯 핵심 포인트

- **비동기 메시징 패턴**: Producer와 Consumer가 독립적으로 동작하며, 카프카가 중간에서 메시지 큐 역할
- **실시간 주문 처리**: Producer가 주문을 생성하면 Consumer가 즉시 수신하여 처리
- **확장 가능한 아키텍처**: Consumer 그룹 설정으로 여러 Consumer가 동시에 주문 처리 가능
- **데이터 파이프라인 기반**: 향후 S3 저장, ETL, OpenSearch, Airflow 연동 등 확장 예정

---

## 📊 전체 타임라인

**[고객 앱에서 주문 생성]** 
   ↓ *1초 간격*
**[Producer가 카프카로 전송]** 
   ↓ *실시간*
**[카프카 Topic에 메시지 저장]** 
   ↓ *즉시*
**[Consumer가 메시지 수신]** 
   ↓
**[매장에서 주문 접수 처리]**

**결론**: Kafka 기반의 실시간 주문 처리 시스템으로, Producer는 주문을 생성하여 카프카에 전송하고, Consumer는 카프카에서 주문을 읽어 처리하는 전형적인 메시징 큐 패턴을 구현했습니다.
